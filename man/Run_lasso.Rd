% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Run_lasso.R
\name{Run_lasso}
\alias{Run_lasso}
\title{Post-processing}
\usage{
Run_lasso(data, par, var, g, lambda = c(8, 4), max = 1000)
}
\arguments{
\item{data}{The CNV dataset prepared for lasso (see \code{\link[graphics]{data_lasso}})}

\item{par}{The parameter prepared for lasso (see \code{\link[graphics]{par_lasso}})}

\item{var}{The initialized variables for lasso  (see \code{\link[graphics]{var_lasso}})}

\item{g}{Integer-valued ploidy}

\item{lambda}{L1-Penalty for all recurrent CNV}

\item{max}{The maximum number of cycles to run}
}
\value{
A list containing the optimal values for variables and the loss array
}
\description{
Solve the lasso-like problem for post-processing
}
\details{
This step makes the solution more biologically interpretable. 
And the lasso-like L1 regularizer makes the result sparser which is crucial for researchers to find region of interest.

This function utilizes a proximal gradient descent method to solve the problem,
and it stops when the improvement is sufficiently small and the dual variable is close to feasible (or it reaches the max number of iterations specified by user).

In post-processing, we don't have separate values for minor and major copies, 
and thus, the result would be an intermediate between changes for minor and major copy.

We find this easier to understand, but if the user indeed wants to have a set of separate values for minor and major copy,
he could copy major copy data file to minor copy and re-load the dataset.
Namely, he could change major and minor copy data file to both contain either minor or major data, and run the lasso.
}
\examples{

Lasso_res<-Run_lasso(wkdata,par,var,g_int)

}
